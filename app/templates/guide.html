<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HDHomeRun TV Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              slate: {
                850: "#1e293b",
                900: "#0f172a",
              },
            },
          },
        },
      };
    </script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap");

      body {
        font-family: "Inter", sans-serif;
      }

      .custom-scrollbar::-webkit-scrollbar {
        height: 8px;
        background: #1e293b;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #475569;
        border-radius: 4px;
      }
    </style>
  </head>

  <body class="bg-slate-900 text-gray-100 min-h-screen p-4 font-sans text-sm">
    <div class="h-screen flex flex-col">
      <!-- Header & Filters -->
      <header
        class="flex justify-between items-center bg-slate-800 p-4 rounded-xl shadow-md border-b border-slate-700 shrink-0 mb-4 z-30"
      >
        <div class="flex items-center gap-6">
          <div>
            <h1
              class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-pink-400"
            >
              TV Guide
            </h1>
          </div>
          <div class="flex gap-4 items-center">
            <!-- Clock -->
            <div
              id="clock"
              class="text-xl font-mono font-bold text-blue-400 bg-slate-900/50 px-3 py-1 rounded border border-slate-600"
            >
              --:--
            </div>
            <div class="h-6 w-px bg-slate-600 mx-2"></div>
            <!-- Filters -->
            <input
              type="text"
              id="filter-channel"
              onkeyup="filterGuide()"
              placeholder="Filter Channel..."
              class="bg-slate-700 text-white px-3 py-1.5 rounded-md border border-slate-600 focus:outline-none focus:border-blue-500 text-sm"
            />
            <input
              type="text"
              id="filter-program"
              onkeyup="filterGuide()"
              placeholder="Filter Program..."
              class="bg-slate-700 text-white px-3 py-1.5 rounded-md border border-slate-600 focus:outline-none focus:border-blue-500 text-sm"
            />
          </div>
        </div>
        <a href="/" class="text-slate-400 hover:text-white transition-colors"
          >‚Üê Dashboard</a
        >
      </header>

      <!-- Main Guide Container -->
      <div
        class="flex-1 overflow-hidden bg-slate-800/50 rounded-xl border border-slate-700 flex flex-col relative"
      >
        {% if not channels %}
        <div class="text-slate-500 italic p-12 text-center">
          No EPG data available
        </div>
        {% endif %}

        <!-- Scrubber Area (Fixed above scrollable area) -->
        <div class="h-[60px] bg-slate-800 relative select-none border-b border-slate-700 z-30 shadow-sm" id="scrubber-track-container">
             <!-- Track -->
            <div class="absolute top-1/2 left-4 right-4 h-1.5 bg-slate-700 rounded-full overflow-hidden transform -translate-y-1/2 cursor-crosshair group" id="scrubber-track">
                <div class="h-full bg-gradient-to-r from-blue-500/50 via-purple-500/50 to-blue-500/50 w-full"></div>
            </div>

            <!-- Lens Cursor (Absolute) -->
            <div id="scrubber-lens" class="absolute top-1/2 pointer-events-none transform -translate-x-1/2 -translate-y-1/2 hidden flex-col items-center gap-1 z-30">
                <div class="w-auto px-3 min-w-[64px] h-8 bg-blue-500/90 backdrop-blur-md rounded-lg shadow-[0_0_15px_rgba(59,130,246,0.5)] border border-blue-400/50 flex items-center justify-center whitespace-nowrap">
                     <span class="text-white font-bold font-mono text-xs" id="lens-time">--:--</span>
                </div>
                <div class="w-0.5 h-8 bg-blue-400/80 shadow-[0_0_10px_rgba(59,130,246,0.8)]"></div>
            </div>
            
            <!-- Active Window Indicator -->
             <div id="scrubber-window" class="absolute top-1/2 h-3 bg-white/20 rounded-full transform -translate-y-1/2 pointer-events-none border border-white/30 backdrop-blur-[1px]" style="left: 0; width: 50px;"></div>
        </div>

        <!-- Scrollable Area -->
        <div class="overflow-auto custom-scrollbar flex-1 relative" id="guide-container">
            
            <!-- Timeline Header Row (Sticky Top) -->
            <div class="flex border-b border-slate-700 bg-slate-800 z-40 sticky top-0 min-w-max">
                <div class="w-48 shrink-0 border-r border-slate-700 p-2 flex items-center justify-center text-slate-400 text-xs font-mono bg-slate-800 sticky left-0 z-50 shadow-[4px_0_10px_rgba(0,0,0,0.3)]">
                    CHANNELS
                </div>
                <!-- Timeline Container -->
                <div class="flex-1 relative h-8 overflow-hidden bg-slate-800" id="timeline-container">
                    <!-- JS will populate markers here -->
                </div>
            </div>
          {% for channel_id, data in grouped_data.items() %}
          <div
            class="flex border-b border-slate-700 group/channel channel-row min-w-max"
            data-channel-name="{{ data.channel.GuideName|lower }}"
          >
            <!-- Left: Channel Header (Sticky) -->
            <div
              class="w-48 shrink-0 bg-slate-800 p-3 border-r border-slate-700 sticky left-0 z-30 flex items-center shadow-[4px_0_10px_rgba(0,0,0,0.3)]"
            >
              {% if data.channel.ImageURL %}
              <img
                src="{{ data.channel.ImageURL }}"
                class="h-10 w-16 object-contain bg-white rounded-md mr-3"
              />
              {% else %}
              <div
                class="h-10 w-16 bg-slate-600 rounded-md mr-3 flex items-center justify-center text-xs"
              >
                No Img
              </div>
              {% endif %}
              <div class="min-w-0">
                <div class="font-bold text-white truncate">
                  {{ data.channel.GuideName }}
                </div>
                <div class="text-xs text-blue-400 font-mono">
                  {{ data.channel.GuideNumber }}
                </div>
              </div>
            </div>

            <!-- Right: Timeline -->
            <div class="flex p-2 items-center min-w-0">
              {% if not data.programmes %}
              <div class="text-slate-500 italic p-2 text-xs">No info</div>
              {% else %} {% for prog in data.programmes %}
              {% if prog.is_gap %}
                <!-- GAP / Spacer -->
                <div class="flex-shrink-0 h-16 bg-[length:10px_10px] bg-repeat" 
                     style="width: {{ prog.width_px }}px; background-image: repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(255,255,255,0.03) 4px, rgba(255,255,255,0.03) 8px);">
                     <!-- Optional: label for large gaps -->
                     {% if prog.width_px > 100 %}
                      <div class="h-full flex items-center justify-center text-xs text-slate-700 font-mono rotate-0 select-none">NO DATA</div>
                     {% endif %}
                </div>
              {% else %}
              <!-- Program Card -->
              <div
                class="flex-none bg-slate-700/80 hover:bg-blue-600/80 rounded border border-slate-600 hover:border-blue-400 transition-all cursor-pointer relative overflow-hidden group/card mr-1 h-16 program-card"
                style="width: {{ prog.width_px }}px;"
                data-program-title="{{ prog.Title|lower }}"
                onclick='openModal({{ prog|tojson }})'
              >
                <!-- Progress Bar -->
                {% if prog.progress_percent > 0 and prog.progress_percent < 100
                %}
                <div
                  class="absolute bottom-0 left-0 h-1 bg-green-500 z-10"
                  style="width: {{ prog.progress_percent }}%;"
                ></div>
                {% endif %}

                <div
                  class="p-2 h-full flex flex-col justify-center relative z-10"
                >
                  <div
                    class="font-bold text-white text-xs truncate leading-tight"
                  >
                    {{ prog.Title }}
                  </div>
                  <div
                    class="text-[10px] text-slate-300 truncate flex justify-between mt-0.5"
                  >
                    <span
                      class="local-time font-mono"
                      data-ts="{{ prog.start_ts }}"
                      >{{ prog.start_str }}</span
                    >
                    {% if prog.EpisodeTitle %}
                    <span class="opacity-70 ml-1 truncate"
                      >- {{ prog.EpisodeTitle }}</span
                    >
                    {% endif %}
                  </div>
                </div>
              </div>
              {% endif %}
              {% endfor %} {% endif %}
            </div>
          </div>
          {% endfor %}
        </div>
      </div>
    </div>

    <!-- Details Modal -->
    <div
      id="modal-overlay"
      class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4"
      onclick="closeModal(event)"
    >
      <div
        class="bg-slate-800 rounded-2xl shadow-2xl border border-slate-600 w-full max-w-lg overflow-hidden transform transition-all scale-95 opacity-0"
        id="modal-content"
      >
        <!-- Modal Header with Image -->
        <div class="relative h-40 bg-slate-700">
          <img
            id="modal-img"
            src=""
            class="w-full h-full object-cover opacity-60"
          />
          <div
            class="absolute inset-0 bg-gradient-to-t from-slate-800 to-transparent"
          ></div>
          <button
            onclick="closeModal()"
            class="absolute top-3 right-3 bg-black/50 hover:bg-black/70 text-white rounded-full p-1 transition-colors"
          >
            <svg
              class="w-6 h-6"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              ></path>
            </svg>
          </button>
          <div class="absolute bottom-4 left-6 right-6">
            <h2
              id="modal-title"
              class="text-2xl font-bold text-white shadow-black drop-shadow-md"
            ></h2>
            <p
              id="modal-episode"
              class="text-blue-300 font-semibold text-sm mt-1"
            ></p>
          </div>
        </div>

        <!-- Modal Body -->
        <div class="p-6">
          <div
            class="flex justify-between items-center text-slate-400 text-xs font-mono mb-4 border-b border-slate-700 pb-3"
          >
            <span id="modal-time"></span>
            <span id="modal-duration"></span>
          </div>

          <p
            id="modal-desc"
            class="text-slate-300 text-sm leading-relaxed max-h-48 overflow-y-auto pr-2 custom-scrollbar"
          >
            <!-- Description -->
          </p>

          <div class="mt-6 flex justify-end">
            <button
              onclick="closeModal()"
              class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-semibold transition-colors"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // --- Clock & Time Logic ---
      function updateClock() {
        const now = new Date();
        const timeString = now.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });
        document.getElementById("clock").innerText = timeString;
      }

      function renderLocalTimes() {
        document.querySelectorAll(".local-time").forEach((el) => {
          const ts = parseFloat(el.getAttribute("data-ts"));
          if (ts) {
            const date = new Date(ts * 1000);
            el.innerText = date.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            });
          }
        });
      }

      function renderTimeline() {
        const container = document.getElementById("timeline-container");
        container.innerHTML = "";

        const now = new Date();
        const currentUnix = now.getTime() / 1000;
        const pixelsPerMinute = 5;

        // Determine next 30-minute intervals
        let start = new Date(now);
        start.setSeconds(0);
        start.setMilliseconds(0);
        const minutes = start.getMinutes();
        if (minutes >= 30) start.setMinutes(30);
        else start.setMinutes(0);

        let timeIterator = new Date(start); 

        // Use server-provided config or fallback to 15
        const daysToRender = {{ epg_days | tojson | default(15) }};
        // Add a small buffer (4 hours) to ensure we cover the last program fully
        const bufferHours = 4;
        const endTime = new Date(now.getTime() + (daysToRender * 24 * 60 * 60 * 1000) + (bufferHours * 60 * 60 * 1000));

        // SYNC HEADER WIDTH
        // Calculate expected width: (Days * Mins/Day * Pixels/Min) + Buffer
        const totalMinutes = (daysToRender * 24 * 60) + (bufferHours * 60);
        const headerWidth = totalMinutes * pixelsPerMinute;
        container.style.minWidth = `${headerWidth}px`;

        while (timeIterator < endTime) {
          const diffSeconds = timeIterator.getTime() / 1000 - currentUnix;

          // Render visible markers (allow some negative for safety)
          if (diffSeconds > -1800) {
            const leftPos = (diffSeconds / 60) * pixelsPerMinute;

            // Marker Line
            const marker = document.createElement("div");
            marker.className =
              "absolute top-0 bottom-0 w-px bg-slate-600/50 flex flex-col items-center";
            marker.style.left = `${leftPos}px`;

            // Time Label
            const label = document.createElement("div");
            label.className =
              "mt-1 text-xs text-slate-400 font-mono bg-slate-800 px-1 rounded";
            label.innerText = timeIterator.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            });

            marker.appendChild(label);
            container.appendChild(marker);
          }

          // Increment 30 mins
          timeIterator.setMinutes(timeIterator.getMinutes() + 30);
        }
      }

      // Init
      document.addEventListener("DOMContentLoaded", () => {
        updateClock();
        setInterval(updateClock, 1000);
        renderLocalTimes();
        
        // Initial Render
        renderTimeline();
        
        // Re-render timeline every minute
        setInterval(renderTimeline, 60000);

        initScrubber();
      });

      // --- Scrubber Logic ---
      function initScrubber() {
          const trackContainer = document.getElementById('scrubber-track-container');
          const guideContainer = document.getElementById('guide-container');
          const windowIndicator = document.getElementById('scrubber-window');
          const lens = document.getElementById('scrubber-lens');
          const lensTime = document.getElementById('lens-time');

          let isDragging = false;

          // Sync Active Window Indicator to Guide Scroll
          guideContainer.addEventListener('scroll', () => {
              updateScrubberWindow();
          });

          // Click / Drag on Track
          trackContainer.addEventListener('mousedown', (e) => {
              isDragging = true;
              scrollToScrubberPos(e.clientX);
          });
          document.addEventListener('mousemove', (e) => {
              if(isDragging) {
                  e.preventDefault();
                  scrollToScrubberPos(e.clientX);
              }
              // Update Lens if hovering track container
              const rect = trackContainer.getBoundingClientRect();
              if(e.clientY >= rect.top && e.clientY <= rect.bottom && e.clientX >= rect.left && e.clientX <= rect.right) {
                  updateLens(e.clientX);
                  lens.classList.remove('hidden');
                  // lens.classList.add('flex'); // It's flex by default but hidden toggle
                  lens.style.display = 'flex';
              } else {
                  lens.classList.add('hidden');
                  lens.style.display = 'none';
              }
          });
          document.addEventListener('mouseup', () => {
              isDragging = false;
          });

          function updateScrubberWindow() {
               // Calculate ratio
               const totalWidth = guideContainer.scrollWidth;
               const visibleWidth = guideContainer.clientWidth;
               const scrollLeft = guideContainer.scrollLeft;

               const trackWidth = trackContainer.clientWidth - 32; // -32 for left/right padding
               const ratio = trackWidth / totalWidth;

               const indicatorWidth = Math.max(visibleWidth * ratio, 20); // Min width
               const indicatorLeft = 16 + (scrollLeft * ratio); // +16 padding

               windowIndicator.style.width = `${indicatorWidth}px`;
               windowIndicator.style.left = `${indicatorLeft}px`;
          }
          
          function scrollToScrubberPos(clientX) {
               const rect = trackContainer.getBoundingClientRect();
               const trackLeft = rect.left + 16;
               const trackWidth = rect.width - 32;
               
               let relX = clientX - trackLeft;
               // Clamp
               if (relX < 0) relX = 0;
               if (relX > trackWidth) relX = trackWidth;

               // Convert to scroll position
               const ratio = relX / trackWidth;
               const totalScrollWidth = guideContainer.scrollWidth - guideContainer.clientWidth;
               
               guideContainer.scrollLeft = totalScrollWidth * ratio;
          }

          function updateLens(clientX) {
               const rect = trackContainer.getBoundingClientRect();
               lens.style.left = `${clientX - rect.left}px`;
               
               // Calculate time at this position
               const trackLeft = rect.left + 16;
               const trackWidth = rect.width - 32;
               let ratio = (clientX - trackLeft) / trackWidth;
               if(ratio < 0) ratio = 0;
               if(ratio > 1) ratio = 1;

               // Total duration in seconds (based on guide content)
               // We need a rough estimate. Let's look at the first channel's last program end time vs "now"
               // Or simpler: The guide is rendered based on pixel width.
               const pixelsPerMinute = 5;
               const totalWidth = guideContainer.scrollWidth;
               const totalMinutes = totalWidth / pixelsPerMinute;
               
               const now = new Date();
               const targetTime = new Date(now.getTime() + (totalMinutes * ratio * 60 * 1000));
               
               // Format: "Day HH:MM"
               const day = targetTime.toLocaleDateString([], {weekday: 'short'});
               const time = targetTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
               
               lensTime.innerText = `${day} ${time}`;
          }

          // Initial call
          setTimeout(updateScrubberWindow, 100); // Wait for layout
      }

      function filterGuide() {
        const chFilter = document
          .getElementById("filter-channel")
          .value.toLowerCase();
        const progFilter = document
          .getElementById("filter-program")
          .value.toLowerCase();
        const rows = document.querySelectorAll(".channel-row");

        rows.forEach((row) => {
          const chName = row.getAttribute("data-channel-name");
          const progCards = row.querySelectorAll(".program-card");

          let hasVisibleProgram = false;

          // Hide programs if filter set
          progCards.forEach((card) => {
            if (!progFilter) {
              card.style.display = "";
              card.style.opacity = "1";
              hasVisibleProgram = true;
            } else {
              const title = card.getAttribute("data-program-title");
              if (title.includes(progFilter)) {
                card.style.display = "";
                card.style.opacity = "1";
                hasVisibleProgram = true;
              } else {
                // Grey out or hide? Let's opacity drop to highlight matches
                card.style.opacity = "0.1";
                // Or display none?
                // card.style.display = 'none';
              }
            }
          });

          // Row visibility based on Channel Name AND if it has matching programs (if prog filter active)
          if (chName.includes(chFilter)) {
            row.style.display = "";
          } else {
            row.style.display = "none";
          }
        });
      }

      function openModal(prog) {
        const overlay = document.getElementById("modal-overlay");
        const content = document.getElementById("modal-content");

        document.getElementById("modal-title").innerText = prog.Title;
        document.getElementById("modal-episode").innerText =
          prog.EpisodeTitle || "";
        document.getElementById("modal-desc").innerText =
          prog.Synopsis || "No description available.";

        // Fix modal time to be local
        const startDate = new Date(prog.start_ts * 1000);
        const endDate = new Date(prog.end_ts * 1000);
        const timeStr =
          startDate.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          }) +
          " - " +
          endDate.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          });
        document.getElementById("modal-time").innerText = timeStr;

        // Duration
        const minutes = Math.round((prog.EndTime - prog.StartTime) / 60);
        document.getElementById("modal-duration").innerText = `${minutes} min`;

        // Image (Try ImageURL, fallback to channel logo maybe? Or generic)
        // HDHomeRun often provides 'ImageURL' at program level if enriched, or 'ThumbnailURL'
        // We'll use what's passed.
        const imgUrl =
          prog.ImageURL ||
          "https://via.placeholder.com/600x300/1e293b/475569?text=No+Preview";
        document.getElementById("modal-img").src = imgUrl;

        overlay.classList.remove("hidden");
        // Animation
        setTimeout(() => {
          content.classList.remove("scale-95", "opacity-0");
          content.classList.add("scale-100", "opacity-100");
        }, 10);
      }

      function closeModal(e) {
        if (e && e.target.id !== "modal-overlay" && !e.target.closest("button"))
          return;

        const overlay = document.getElementById("modal-overlay");
        const content = document.getElementById("modal-content");

        content.classList.remove("scale-100", "opacity-100");
        content.classList.add("scale-95", "opacity-0");

        setTimeout(() => {
          overlay.classList.add("hidden");
        }, 200);
      }
    </script>
  </body>
</html>
